<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>记一次java.lang.NoClassDefFoundError异常排查</title>
    <url>/2020/04/04/%E8%AE%B0%E4%B8%80%E6%AC%A1java-lang-NoClassDefFoundError%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<p>最近在把项目发到生产环境时，遇到了这样到一个错误，解决这个问题着实花费了不少到时间：</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: com/xxx/xxx/MetaConfigClientImpl
at com.xxx.xxx.notify.cp.utils.PropertyHolder.&lt;clinit&gt;(PropertyHolder.java:25)
at com.xxx.xxx.notify.cp.realtime.RealTimeMarketNotifyMain.run(RealTimeMarketNotifyMain.java:43)
at com.xxx.xxx.notify.cp.realtime.RealTimeMarketNotifyMain.main(RealTimeMarketNotifyMain.java:29)
Caused by: java.lang.ClassNotFoundException: com.xxx.xxx.MetaConfigClientImpl
at java.net.URLClassLoader.findClass(URLClassLoader.java:382)
at java.lang.ClassLoader.loadClass(ClassLoader.java:418)
at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:352)
at java.lang.ClassLoader.loadClass(ClassLoader.java:351)
... 3 more</code></pre><p>MetaConfigClientImpl 这个类是我自己写到一个工具类，通过maven依赖到方式引入到项目中，依赖方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.xxx.xxx&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jae-meta-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.8-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>该包在公司的很多项目都有使用到，从来没有出现这种问题，根据自己到经验，一般这种开发没问题，生产环境找不到包到情况，都是依赖冲突导致的。因此首先把重点放在依赖冲突的排查上面，先通过maven dependency tree来看，没发现与该包的冲突，反而是其他一些日志依赖之类的冲突去掉了不少，后来通过idea的插件dependency analyzer来排查，还是没发现有冲突的地方。本着试一试的心态，将一些不相关的冲突去掉后，重新发到生产环境上，结果不出意外，还是不行。<br>既然不是依赖冲突的问题，由于本人的开发环境是mac，生产环境是linux，按理来说区别不大，因此生产跟开发环境的差别就剩打包跟运行这两个地方，该项目的打包命令如下：</p>
<pre><code>&lt;build&gt;
&lt;sourceDirectory&gt;src/main/java&lt;/sourceDirectory&gt;
&lt;plugins&gt;
  &lt;plugin&gt;
    &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.5&lt;/version&gt;
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;id&gt;copy-config&lt;/id&gt;
        &lt;phase&gt;process-sources&lt;/phase&gt;
        &lt;goals&gt;
          &lt;goal&gt;copy-resources&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
          &lt;outputDirectory&gt;${project.build.directory}/conf&lt;/outputDirectory&gt;
          &lt;resources&gt;
            &lt;resource&gt;
              &lt;directory&gt;src/main/resources&lt;/directory&gt;
              &lt;includes&gt;
                &lt;include&gt;**/*&lt;/include&gt;
              &lt;/includes&gt;
            &lt;/resource&gt;
          &lt;/resources&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
  &lt;/plugin&gt;
  &lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.6.1&lt;/version&gt;
    &lt;configuration&gt;
      &lt;source&gt;1.8&lt;/source&gt;
      &lt;target&gt;1.8&lt;/target&gt;
    &lt;/configuration&gt;
  &lt;/plugin&gt;
  &lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;*&lt;/exclude&gt;
      &lt;/excludes&gt;
       &lt;outputDirectory&gt;${project.build.directory}/jar&lt;/outputDirectory&gt;
      &lt;archive&gt;
        &lt;manifest&gt;
          &lt;mainClass&gt;com.xxx.xxx.xxx.xxx.xxxx.RealTimeMarketNotifyMain&lt;/mainClass&gt;
          &lt;addClasspath&gt;true&lt;/addClasspath&gt;
          &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;
        &lt;/manifest&gt;
        &lt;manifestEntries&gt;
          &lt;Class-Path&gt;conf/&lt;/Class-Path&gt;
        &lt;/manifestEntries&gt;
      &lt;/archive&gt;
      &lt;classesDirectory/&gt;
    &lt;/configuration&gt;
  &lt;/plugin&gt;
  &lt;plugin&gt;
    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;phase&gt;package&lt;/phase&gt;
        &lt;goals&gt;
          &lt;goal&gt;copy-dependencies&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
          &lt;outputDirectory&gt;${project.build.directory}/lib/&lt;/outputDirectory&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
  &lt;/plugin&gt;
&lt;/plugins&gt;
 &lt;/build&gt;</code></pre><p>打包后，会将配置文件放在conf目录下，依赖包放在lib目录下。生产环境的lib目录下是能看到jae-meta-config这个依赖的，将lib目录下所有的文件进行md5，而后将开发环境下lib包目录的所有文件进行md5，两者进行string diff对比，发现一模一样。打出来的依赖包明明都一样，这说明应该不是依赖包的问题。<br>而后看运行的方式，打开生产环境的启动脚本，发现启动命令如下：</p>
<pre><code>exec gosu ubuntu java  -Xmx${memory}m -Xms${memory}m -XX:+UseG1GC -XX:MaxGCPauseMillis=200  -Xloggc:/app/logs/gc-%t.log  -XX:+PrintGCDetails  -XX:+PrintGCDateStamps   -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=50000K    -XX:+ExitOnOutOfMemoryError   -cp \&quot;conf/:jar/*:lib/*\&quot;  -jar /app/RealTimeMarketNotifyMain.jar com.xxx.xxx.xxx.xxx.xxx.RealTimeMarketNotifyMain</code></pre><p>而我在本地启动时是直接用 java  -cp &quot;conf/:jar/<em>:lib/</em>&quot; com.xxx.xxx.xxx.xxx.xxx.RealTimeMarketNotifyMain com.xxx.xxx.xxx.xxx.xxx.RealTimeMarketNotifyMain启动的，查阅资料后发现，使用java -jar 时，-cp是不生效的，而是会用到META-INF\MANIFEST.MF 文件的配置启动，尝试了一下，在生产环境使用java -cp命令启动发现是能够正常启动的。至此，问题可以定位到启动方式之间的差距导致的。<br>但是从上面的打包命令上可以看到，我们在maven里面指定了主类，依赖包路径已经配置文件的路径，按理来说直接用java -jar的方式启动也是没问题的</p>
<pre><code>&lt;archive&gt;
    &lt;manifest&gt;
      &lt;mainClass&gt;com.xxx.xxx.xxx.xxx.xxxx.RealTimeMarketNotifyMain&lt;/mainClass&gt;
      &lt;addClasspath&gt;true&lt;/addClasspath&gt;
      &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;
    &lt;/manifest&gt;
    &lt;manifestEntries&gt;
      &lt;Class-Path&gt;conf/&lt;/Class-Path&gt;
    &lt;/manifestEntries&gt;
  &lt;/archive&gt;</code></pre><p>使用jar-gui解开jar包，查看里面的MANIFEST.MF文件，终于发现问题：<br><img src="https://garjun-blog-1255506252.cos.ap-guangzhou.myqcloud.com/2020/2020040401.png" alt="MANIFEST"></p>
<p>在MANIFEST.MF文件中，指定引入的lib包的名字有一个时间戳，而lib文件夹下的文件名为</p>
<pre><code>jae-meta-config-1.8-SNAPSHOT.jar</code></pre><p>因此，在使用java -jar命令运行时，会找不到对应的类<br>随之而来的问题是，为什么会有这样的一个时间戳？<br>在仔细查看maven的文档后发现<br><img src="https://garjun-blog-1255506252.cos.ap-guangzhou.myqcloud.com/2020/2020040402.png" alt="maven文档"></p>
<p>maven有一个useUniqueVersions的配置，该配置的作用是在生产MANIFES.MF文件时，SNATSHOP版本的jar包是否要打上唯一版本时间戳，该配置默认值为true,因此jae-meta-config-1.8-SNAPSHOT.jar 变成了 jae-jbaseclient-2.0.2-20191104.060124-1.jar。导致找不到对应的jar包，启动报错。重新打包配置，将该配置设为false</p>
<pre><code>&lt;archive&gt;
   &lt;manifest&gt;
     &lt;mainClass&gt;com.xxx.xxx.xxx.xxx.xxx.RealTimeMarketNotifyMain&lt;/mainClass&gt;
     &lt;addClasspath&gt;true&lt;/addClasspath&gt;
     &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;
     &lt;useUniqueVersions&gt;false&lt;/useUniqueVersions&gt;
   &lt;/manifest&gt;
   &lt;manifestEntries&gt;
     &lt;Class-Path&gt;conf/&lt;/Class-Path&gt;
   &lt;/manifestEntries&gt;
 &lt;/archive&gt;</code></pre><p>而后使用java -jar的方式启动，一切正常<br>至此，真相大白</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol>
<li>java -jar 和 -cp 同时使用时，-cp的配置是不生效的，java会根据MANIFEST.MF的配置来启动</li>
<li>maven 打包时，useUniqueVersions配置如果默认时打开的，如果用到了SNATSHOP版本的依赖包，应该特别注意，要么使用java -cp的方式启动，如果要使用java -jar的方式启动，最好将该配置设为false</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot简化配置原理以及Mybatis-spring-boot-starter原理探索</title>
    <url>/2020/03/08/SpringBoot%E7%AE%80%E5%8C%96%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AMybatis-spring-boot-starter%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="Spring-Boot-Starter简化开发原理"><a href="#Spring-Boot-Starter简化开发原理" class="headerlink" title="Spring Boot Starter简化开发原理"></a>Spring Boot Starter简化开发原理</h2><p>在我刚学spring的时候，让我印象深刻的是各种xml的配置，而且很多配置是这个项目配一遍，开新项目时又把旧项目的配置复制一遍，而且比较容易出错，调试一下又要费不少的时间。Starter简化了这些繁琐的配置，遵循Spring Boot“约定大约配置”的理念，在我们不主动进行配置时给予默认的属性，而且很多情况下这些属性都不需要更改。这是怎么实现的呢？<br>在SpringApplication这个类，也就是启动类上有一个@SpringApplication的注解，该注解是由@SpringBootConfiguration,@EnableAutoConfiguration,@ComponentScan这三个注解组合而成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(excludeFilters &#x3D; &#123; @Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; TypeExcludeFilter.class),</span><br><span class="line">		@Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br><span class="line">    &#x2F;&#x2F;不重要的内容忽略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点开@EnableAutoConfiguration,可以看到该注解导入了一个AutoConfigurationImportSelector的类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(AutoConfigurationImportSelector.class)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">   String ENABLED_OVERRIDE_PROPERTY &#x3D; &quot;spring.boot.enableautoconfiguration&quot;;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Exclude specific auto-configuration classes such that they will never be applied.</span><br><span class="line">    * @return the classes to exclude</span><br><span class="line">    *&#x2F;</span><br><span class="line">   Class&lt;?&gt;[] exclude() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Exclude specific auto-configuration class names such that they will never be</span><br><span class="line">    * applied.</span><br><span class="line">    * @return the class names to exclude</span><br><span class="line">    * @since 1.3.0</span><br><span class="line">    *&#x2F;</span><br><span class="line">   String[] excludeName() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们重点看这个类:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware,</span><br><span class="line">ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123;</span><br><span class="line">      </span><br><span class="line">        &#x2F;&#x2F; 忽略不重要的内容  </span><br><span class="line">         </span><br><span class="line">        @Override</span><br><span class="line">	    public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">		if (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">			return NO_IMPORTS;</span><br><span class="line">		&#125;</span><br><span class="line">		AutoConfigurationMetadata autoConfigurationMetadata &#x3D; AutoConfigurationMetadataLoader</span><br><span class="line">				.loadMetadata(this.beanClassLoader);</span><br><span class="line">		AutoConfigurationEntry autoConfigurationEntry &#x3D; getAutoConfigurationEntry(autoConfigurationMetadata,</span><br><span class="line">				annotationMetadata);</span><br><span class="line">		return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>该类继承了DeferredImportSelector,而DeferredImportSelector继承了ImportSelector。这里有一个小知识：<br><strong>在使用@Import注解来注册bean的时候，Import注解的值可以是ImportSelector的实现类，spring容器会实例化这个实现类，并执行其selectImports方法</strong><br>因此，spring会调用该类的selectImports方法，而大家注意，这个类继承的是DeferredImportSelector，因此，这个类会在其他@Configuration加载后才会进行加载。接下来我们重点看selectImports方法，该方法调用了getAutoConfigurationEntry(autoConfigurationMetadata,annotationMetadata)，进入这个方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata,</span><br><span class="line">			AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">		if (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">			return EMPTY_ENTRY;</span><br><span class="line">		&#125;</span><br><span class="line">		AnnotationAttributes attributes &#x3D; getAttributes(annotationMetadata);</span><br><span class="line">        &#x2F;&#x2F;重点</span><br><span class="line">		List&lt;String&gt; configurations &#x3D; getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">		configurations &#x3D; removeDuplicates(configurations);</span><br><span class="line">		Set&lt;String&gt; exclusions &#x3D; getExclusions(annotationMetadata, attributes);</span><br><span class="line">		checkExcludedClasses(configurations, exclusions);</span><br><span class="line">		configurations.removeAll(exclusions);</span><br><span class="line">		configurations &#x3D; filter(configurations, autoConfigurationMetadata);</span><br><span class="line">		fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">		return new AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>其中，这个方法调用了getCandidateConfigurations(annotationMetadata, attributes);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">		List&lt;String&gt; configurations &#x3D; SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">				getBeanClassLoader());</span><br><span class="line">		Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF&#x2F;spring.factories. If you &quot;</span><br><span class="line">				+ &quot;are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">		return configurations;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>继续进入SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),getBeanClassLoader());</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">		String factoryTypeName &#x3D; factoryType.getName();</span><br><span class="line">		return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法又调用了loadSpringFactories(classLoader),重点来了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">		MultiValueMap&lt;String, String&gt; result &#x3D; cache.get(classLoader);</span><br><span class="line">		if (result !&#x3D; null) &#123;</span><br><span class="line">			return result;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">                        &#x2F;&#x2F;重点</span><br><span class="line">			Enumeration&lt;URL&gt; urls &#x3D; (classLoader !&#x3D; null ?</span><br><span class="line">					classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">					ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">			result &#x3D; new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">			while (urls.hasMoreElements()) &#123;</span><br><span class="line">				URL url &#x3D; urls.nextElement();</span><br><span class="line">				UrlResource resource &#x3D; new UrlResource(url);</span><br><span class="line">				Properties properties &#x3D; PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">				for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">					String factoryTypeName &#x3D; ((String) entry.getKey()).trim();</span><br><span class="line">					for (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">						result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			cache.put(classLoader, result);</span><br><span class="line">			return result;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (IOException ex) &#123;</span><br><span class="line">			throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +</span><br><span class="line">					FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，该方法会从FACTORIES_RESOURCE_LOCATION中获取需要自动配置的类，而FACTORIES_RESOURCE_LOCATION的具体内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * The location to look for factories.</span><br><span class="line"> * &lt;p&gt;Can be present in multiple JAR files.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static final String FACTORIES_RESOURCE_LOCATION &#x3D; &quot;META-INF&#x2F;spring.factories&quot;;</span><br></pre></td></tr></table></figure>
<p>因此，我们可以得出结论spring会从包的类”META-INF/spring.factories”中读取需要自动配置的类，从而实现springboot的自动配置。下面我们用一个常用的starter，验证一下我们得出的结论是否正确</p>
<h2 id="mybatis-spring-boot-starter-原理探索"><a href="#mybatis-spring-boot-starter-原理探索" class="headerlink" title="mybatis-spring-boot-starter 原理探索"></a>mybatis-spring-boot-starter 原理探索</h2><p>打开mybatis-spring-boot-starter这个jar，可以看到只有这几个文件<br><img src="https://garjun-blog-1255506252.cos.ap-guangzhou.myqcloud.com/2020/2020030801.jpg" alt="mybatis-spring-boot-starter"></p>
<p>点开pom文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.0&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;&#x2F;parent&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;name&gt;mybatis-spring-boot-starter&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">    &lt;module.name&gt;org.mybatis.spring.boot.starter&lt;&#x2F;module.name&gt;</span><br><span class="line">  &lt;&#x2F;properties&gt;</span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-spring-boot-autoconfigure&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">  &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>
<p>这里有一个点，就是starter的作用有两个，一个是依赖管理，另外一个是启动某些功能，这个pom文件体现的就是依赖管理的作用，将该功能所需要的依赖自动引入。而下面这个依赖则是mybatis自动配置的关键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-spring-boot-autoconfigure&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://garjun-blog-1255506252.cos.ap-guangzhou.myqcloud.com/2020/2020030803.jpg" alt="mybatis-spring-boot-autoconfigure"></p>
<p>我们主要看两个类，一个是MybatisProperties，一个是MybatisAutoConfiguration，这两个类的命名是有规范的，以AutoConfiguration结尾的，是一个javaConfig形式的配置类，对标spring中以xml形式配置的类，而以Properties结尾的类，其作是从配置文件中读取属性。而AutoConfiguration类会从对应的Properties中获取属性进行配置。打开MybatisProperties类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Configuration properties for MyBatis.</span><br><span class="line"> *</span><br><span class="line"> * @author Eddú Meléndez</span><br><span class="line"> * @author Kazuki Shimizu</span><br><span class="line"> *&#x2F;</span><br><span class="line">@ConfigurationProperties(prefix &#x3D; MybatisProperties.MYBATIS_PREFIX)</span><br><span class="line">public class MybatisProperties &#123;</span><br><span class="line"></span><br><span class="line">  public static final String MYBATIS_PREFIX &#x3D; &quot;mybatis&quot;;</span><br><span class="line"></span><br><span class="line">  private static final ResourcePatternResolver resourceResolver &#x3D; new PathMatchingResourcePatternResolver();</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Location of MyBatis xml config file.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  private String configLocation;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Locations of MyBatis mapper files.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  private String[] mapperLocations;</span><br><span class="line">  &#x2F;&#x2F;    忽略下面的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，这个类使用了@ConfigurationProperties注解，这个注解的作用是从配置文件中读取前缀为mybatis的属性，注入到匹配的属性上，如key为mybatis.configLocation的值，就会被注入到该类configLocation的属性上面。接下来我们看一下MyBatisAutoConfiguration的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@org.springframework.context.annotation.Configuration</span><br><span class="line">@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)</span><br><span class="line">@ConditionalOnSingleCandidate(DataSource.class)</span><br><span class="line">@EnableConfigurationProperties(MybatisProperties.class)</span><br><span class="line">@AutoConfigureAfter(&#123; DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class &#125;)</span><br><span class="line">public class MybatisAutoConfiguration implements InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">  private static final Logger logger &#x3D; LoggerFactory.getLogger(MybatisAutoConfiguration.class);</span><br><span class="line"></span><br><span class="line">  private final MybatisProperties properties;</span><br><span class="line"></span><br><span class="line">  private final Interceptor[] interceptors;</span><br><span class="line"></span><br><span class="line">  private final TypeHandler[] typeHandlers;</span><br><span class="line"></span><br><span class="line">  private final LanguageDriver[] languageDrivers;</span><br><span class="line"></span><br><span class="line">  private final ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">  private final DatabaseIdProvider databaseIdProvider;</span><br><span class="line"></span><br><span class="line">  private final List&lt;ConfigurationCustomizer&gt; configurationCustomizers;</span><br><span class="line"></span><br><span class="line">  public MybatisAutoConfiguration(MybatisProperties properties, ObjectProvider&lt;Interceptor[]&gt; interceptorsProvider,</span><br><span class="line">      ObjectProvider&lt;TypeHandler[]&gt; typeHandlersProvider, ObjectProvider&lt;LanguageDriver[]&gt; languageDriversProvider,</span><br><span class="line">      ResourceLoader resourceLoader, ObjectProvider&lt;DatabaseIdProvider&gt; databaseIdProvider,</span><br><span class="line">      ObjectProvider&lt;List&lt;ConfigurationCustomizer&gt;&gt; configurationCustomizersProvider) &#123;</span><br><span class="line">    this.properties &#x3D; properties;</span><br><span class="line">    this.interceptors &#x3D; interceptorsProvider.getIfAvailable();</span><br><span class="line">    this.typeHandlers &#x3D; typeHandlersProvider.getIfAvailable();</span><br><span class="line">    this.languageDrivers &#x3D; languageDriversProvider.getIfAvailable();</span><br><span class="line">    this.resourceLoader &#x3D; resourceLoader;</span><br><span class="line">    this.databaseIdProvider &#x3D; databaseIdProvider.getIfAvailable();</span><br><span class="line">    this.configurationCustomizers &#x3D; configurationCustomizersProvider.getIfAvailable();</span><br><span class="line">  &#125;</span><br><span class="line">    &#x2F;&#x2F;省略部分代码</span><br><span class="line"></span><br><span class="line">  @Bean</span><br><span class="line">  @ConditionalOnMissingBean</span><br><span class="line">  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception &#123;</span><br><span class="line">    SqlSessionFactoryBean factory &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">    factory.setDataSource(dataSource);</span><br><span class="line">    factory.setVfs(SpringBootVFS.class);</span><br><span class="line">    if (StringUtils.hasText(this.properties.getConfigLocation())) &#123;</span><br><span class="line">      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));</span><br><span class="line">    &#125;</span><br><span class="line">    applyConfiguration(factory);</span><br><span class="line">    if (this.properties.getConfigurationProperties() !&#x3D; null) &#123;</span><br><span class="line">      factory.setConfigurationProperties(this.properties.getConfigurationProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    if (!ObjectUtils.isEmpty(this.interceptors)) &#123;</span><br><span class="line">      factory.setPlugins(this.interceptors);</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.databaseIdProvider !&#x3D; null) &#123;</span><br><span class="line">      factory.setDatabaseIdProvider(this.databaseIdProvider);</span><br><span class="line">    &#125;</span><br><span class="line">    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) &#123;</span><br><span class="line">      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.properties.getTypeAliasesSuperType() !&#x3D; null) &#123;</span><br><span class="line">      factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());</span><br><span class="line">    &#125;</span><br><span class="line">    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) &#123;</span><br><span class="line">      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());</span><br><span class="line">    &#125;</span><br><span class="line">    if (!ObjectUtils.isEmpty(this.typeHandlers)) &#123;</span><br><span class="line">      factory.setTypeHandlers(this.typeHandlers);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) &#123;</span><br><span class="line">      factory.setMapperLocations(this.properties.resolveMapperLocations());</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;String&gt; factoryPropertyNames &#x3D; Stream</span><br><span class="line">        .of(new BeanWrapperImpl(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)</span><br><span class="line">        .collect(Collectors.toSet());</span><br><span class="line">    Class&lt;? extends LanguageDriver&gt; defaultLanguageDriver &#x3D; this.properties.getDefaultScriptingLanguageDriver();</span><br><span class="line">    if (factoryPropertyNames.contains(&quot;scriptingLanguageDrivers&quot;) &amp;&amp; !ObjectUtils.isEmpty(this.languageDrivers)) &#123;</span><br><span class="line">      &#x2F;&#x2F; Need to mybatis-spring 2.0.2+</span><br><span class="line">      factory.setScriptingLanguageDrivers(this.languageDrivers);</span><br><span class="line">      if (defaultLanguageDriver &#x3D;&#x3D; null &amp;&amp; this.languageDrivers.length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        defaultLanguageDriver &#x3D; this.languageDrivers[0].getClass();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (factoryPropertyNames.contains(&quot;defaultScriptingLanguageDriver&quot;)) &#123;</span><br><span class="line">      &#x2F;&#x2F; Need to mybatis-spring 2.0.2+</span><br><span class="line">      factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return factory.getObject();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;省略部分代码</span><br><span class="line">  @Bean</span><br><span class="line">  @ConditionalOnMissingBean</span><br><span class="line">  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) &#123;</span><br><span class="line">    ExecutorType executorType &#x3D; this.properties.getExecutorType();</span><br><span class="line">    if (executorType !&#x3D; null) &#123;</span><br><span class="line">      return new SqlSessionTemplate(sqlSessionFactory, executorType);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return new SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先从注解看起：<br>@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class })<br>这个注解表示只有存在sqlSessionFactory和SqlSessionFactoryBean这两个类时，才会初始化该类；<br>@ConditionalOnSingleCandidate(DataSource.class)<br>这个注解表示，只有在仅有一个DataSource.class的或者有多个DataSource，但是指定了首选dataSource时，才会初始化本类（这就是在配置多数据源时要指定首选数据源的原因）<br>@EnableConfigurationProperties(MybatisProperties.class)<br>这个注解的作用是使MybatisProperties上的@ConfigurationProperties生效<br>@AutoConfigureAfter({ DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class })<br>这个注解的作用是指定当前类加载的顺序<br>接下来是sqlSessionFactory方法和sqlSessionTemplate方法，这两个方法都有@Bean和@ConditionalOnMissingBean注解，<br>这表明spring会在用户没有自定义SqlSessionFactory或SqlSessionTemplate的时候自动配置这两个bean。<br>最后我们打开META-INF文件夹，这里我们看到了一个熟悉的文件：spring.factories，打开文件可以看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\</span><br><span class="line">org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span><br></pre></td></tr></table></figure>
<p>根据我们上一部分所学的知识，spring会自动的去配置这两个类，至此，我们可以稍微理一下整个自动加载的流程是怎样的：</p>
<p>1.SpringBootApplication启动类在运行时扫描到@SpringBootApplication注解，该注解是由多个注解组合而成，其中一个注解是@Import(AutoConfigurationImportSelector.class)，该类实现ImportSelector接口,当@Import所指定的类是一个ImportSelector的实现类时，springbootApplication会运行其selectImports方法，selectImport方法会扫描所有jar包META-INF文件夹下面的spring.factories文件，然后会以org.springframework.boot.autoconfigure.EnableAutoConfiguration为key，获取所有value，组成一个List，接着会扫描这些List中的类</p>
<p>2.由于mybatis-spring-boot-starter中的spring.factories，因此spring会扫描org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration<br>这个类，而由于该类上的注解，因此该类只会在存在<br>1.sqlSessionFactory和SqlSessionFactoryBean这两个类<br>2.只有在仅有一个DataSource.class的或者有多个DataSource，但是指定了首选dataSource<br>这两个条件都符合的情况下初始化，且由于@AutoConfigureAfter注解，该类的初始化顺序是在<br>DataSourceAutoConfiguration和MybatisLanguageDriverAutoConfiguration后面<br>同时，该类上的@EnableConfigurationProperties注解会使MybatisProperties这个类上的@ConfigurationProperties生效，因此会读取配置文件上所有mybatis为前缀的属性，并匹配到该类的属性上。</p>
<p>3.在初始化MybatisAutoConfiguration时，由于sqlSessionFactory(DataSource dataSource)和sqlSessionTemplate(SqlSessionFactory sqlSessionFactory)这两个方法上有@Bean和  @ConditionalOnMissingBean<br>这两个注解，因此spring会在用户没有自定义sqlSessionFactory或sqlSessionTemplate的情况下自动使用MybatisProperties这个类从配置文件读取的值来进行初始化，若没有在配置文件读取到对应到属性，则会使用默认值</p>
<p>4.最后，我们感受到的效果是，只要引入mybatis-spring-boot-starter这个依赖，就可以使用mybatis对数据进行访问，而dataSource,sqlSessionFactory这些东西有时候我们自己配置也可以，不配置也可以的原因。</p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC工作流程</title>
    <url>/2020/03/06/SpringMVC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="SpringMVC工作流程"><a href="#SpringMVC工作流程" class="headerlink" title="SpringMVC工作流程"></a>SpringMVC工作流程</h1><hr>
<p> SpringMVC的核心在于它的流程，所以了解SpringMVC的工作流程对于我们使用SpringMVC非常重要，SpringMVC是一种基于Servlet的技术，它提供了核心控制器DispatcherServlet和相关组件。其流程图：</p>
<p><img src="https://garjun-blog-1255506252.cos.ap-guangzhou.myqcloud.com/2020/2715697938.png" alt="流程图"></p>
<p>1.首先用户发送一个请求到服务器，在使用springMVC之前，我们应该在web.xml对DispatcherServlet进行配置过了：</p>
<pre><code>&lt;!--使用Spring MVC,配置DispatcherServlet是第一步。DispatcherServlet是一个Servlet,,所以可以配置多个DispatcherServlet--&gt;  
   &lt;servlet&gt;  
       &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;
       &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  
       &lt;!--指明了配置文件的文件名，不使用默认配置文件名，而使用dispatcher-servlet.xml配置文件。--&gt;  
       &lt;init-param&gt;  
           &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  
           &lt;param-value&gt;classpath:spring/dispatcher-servlet.xml&lt;/param-value&gt;  
       &lt;/init-param&gt;  
       &lt;!--是启动顺序，让这个Servlet随Servletp容器一起启动。--&gt; 
       &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 
   &lt;/servlet&gt;  
   &lt;servlet-mapping&gt;   
       &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;  
       &lt;!--会拦截URL中带“/”的请求。--&gt;  
       &lt;url-pattern&gt;/&lt;/url-pattern&gt; 
   &lt;/servlet-mapping&gt;  </code></pre><p>  如果使用springBoot，那么springBoot会帮我们注册一个默认的DispatcherServlet,而如果该请求与配置中的url-pattern匹配的话，该请求就会交由该DispatcherServlet来进行处理<br>2.DispatcherServlet根据url，遍历HandlerMappings，获得由处理器和拦截器组成的执行链返回给DispatcherServlet,<br>其源码如下，遍历HandlerMappings(初始化时获得），如果当中有一个HandlerMapping调用getHandler方法时返回值不为null，那么getHandler就会返回一个由拦截器和处理器组成的HandlerExecutionChain执行链。</p>
<pre><code>protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
    for (HandlerMapping hm : this.handlerMappings) {
        if (logger.isTraceEnabled()) {
            logger.trace(
                    &quot;Testing handler map [&quot; + hm + &quot;] in DispatcherServlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;);
        }
        HandlerExecutionChain handler = hm.getHandler(request);
        if (handler != null) {
            return handler;
        }
    }
    return null;
}</code></pre><p>3.将获得的执行链返回给DispatcherServlet<br>4.根据获得的Handler调用HandlerAdapter，其实现也是类似，遍历HandlerAdapters,如果类型匹配则返回该HandlerAdapter，源码如下：</p>
<pre><code>protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {
    for (HandlerAdapter ha : this.handlerAdapters) {
        if (ha.supports(handler)) {
            return ha;
        }
    }
    throw new ServletException(&quot;No adapter for handler [&quot; + handler +
            &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;);
}</code></pre><p>注意：此时会依次执行拦截器的preHandle方法，如果遇到一个拦截器return false就会停止<br>5.提取request中的数据模型，进行数据转换，数据格式化，数据验证等操作，然后执行Handler，调用具体的方法，其实现如下，其中handleInternal由具体的Adapter,比如@RequestMapping注解的handler会由RequestMappingHandlerAdapter来处理。这里就不继续分析源码了，想看源码详细分析的话这个大兄弟写得很好<a href="https://my.oschina.net/marvelcode/blog/1838329" target="_blank" rel="noopener">SpringMVC源码分析（2）：分析HandlerAdapter.handle方法，了解handler方法的调用细节以及@ModelAttribute注解</a>：</p>
<pre><code>public abstract class AbstractHandlerMethodAdapter extends WebContentGenerator implements HandlerAdapter, Ordered {

    private int order = Ordered.LOWEST_PRECEDENCE;
    @Override
    public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
      throws Exception {
        return handleInternal(request, response, (HandlerMethod) handler);
    }
        //抽象方法，由具体的Adapter实现
        protected abstract ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception;

}</code></pre><p>6.handleInternal的具体实现会执行一个invokeHandlerMethod ,执行后会返回一个ModelAndView视图，源码：</p>
<pre><code>protected ModelAndView invokeHandlerMethod(HttpServletRequest request,  
   HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {  
   .........  
   //执行Controller中的RequestMapping注释的方法  
   invocableMethod.invokeAndHandle(webRequest, mavContainer);  

   //返回ModelAndView视图  
   return getModelAndView(mavContainer, modelFactory, webRequest);  
   }  </code></pre><p>7.HandleAdapter返回ModelAndView给DispatcherServlet（注意：在下一步渲染视图之前会执行postHandle方法）<br>8~9.解析视图和渲染视图都是在render方法里面执行的, render方法如下：</p>
<pre><code>    protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {
    // Determine locale for request and apply it to the response.
    Locale locale = this.localeResolver.resolveLocale(request);
    response.setLocale(locale);

    View view;
    if (mv.isReference()) {
        // We need to resolve the view name.
        view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);
        if (view == null) {
            throw new ServletException(&quot;Could not resolve view with name &apos;&quot; + mv.getViewName() +
                    &quot;&apos; in servlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;);
        }
    }
    else {
        // No need to lookup: the ModelAndView object contains the actual View object.
        view = mv.getView();
        if (view == null) {
            throw new ServletException(&quot;ModelAndView [&quot; + mv + &quot;] neither contains a view name nor a &quot; +
                    &quot;View object in servlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;);
        }
    }

    // Delegate to the View object for rendering.
    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Rendering view [&quot; + view + &quot;] in DispatcherServlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;);
    }
    try {
        view.render(mv.getModelInternal(), request, response);
    }
    catch (Exception ex) {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Error rendering view [&quot; + view + &quot;] in DispatcherServlet with name &apos;&quot; +
                    getServletName() + &quot;&apos;&quot;, ex);
        }
        throw ex;
    }
}</code></pre><p>其中，</p>
<pre><code>view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);</code></pre><p>这个方法会遍历DispatcherServlet中的ViewResolver集合并返回对应的视图，对应流程图中的第八步和第九步<br>10.上面的render方法中的：</p>
<pre><code>view.render(mv.getModelInternal(), request, response);</code></pre><p>则是渲染视图的方法(渲染视图后会执行拦截器的afterCompletion方法），其实现类源码如下：</p>
<pre><code>public abstract class 

    AbstractView extends WebApplicationObjectSupport implements View, BeanNameAware {
        ... ...
        @Override
        public void render(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request,
                HttpServletResponse response) throws Exception {

            if (logger.isTraceEnabled()) {
                logger.trace(&quot;Rendering view with name &apos;&quot; + this.beanName + &quot;&apos; with model &quot; + model +
                    &quot; and static attributes &quot; + this.staticAttributes);
            }

            // 创建整合后需要返回给浏览器的Model
            Map&lt;String, Object&gt; mergedModel = createMergedOutputModel(model, request, response);
            // 设置response 报文头
            prepareResponse(request, response);
            // 渲染数据，通过模板方法由子类实现，如InternalResourceView
            renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);
        }
        ... ...
    }</code></pre><p>11.上面view.render方法的最后一步：</p>
<pre><code>renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);</code></pre><p>其源码如下：</p>
<pre><code>@Override
protected void renderMergedOutputModel(
        Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception {

    // 将model中的数据设置到request
    exposeModelAsRequestAttributes(model, request);

    // 本类中的此函数是空函数，留给子类比如JstlView去实现自定义逻辑
    exposeHelpers(request);

    // 跳转目的页面路径
    String dispatcherPath = prepareForRendering(request, response);

    // 获取跳转控制器RequestDispatcher  
    RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);
    if (rd == null) {
        throw new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() +
                &quot;]: Check that the corresponding file exists within your web application archive!&quot;);
    }

    // 直接返回用户资源 
    if (useInclude(request, response)) {
        response.setContentType(getContentType());
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Including resource [&quot; + getUrl() + &quot;] in InternalResourceView &apos;&quot; + getBeanName() + &quot;&apos;&quot;);
        }
        rd.include(request, response);
    }
    // 携带request和response跳转到另一个控制器方法
    else {
        // Note: The forwarded resource is supposed to determine the content type itself.
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Forwarding to resource [&quot; + getUrl() + &quot;] in InternalResourceView &apos;&quot; + getBeanName() + &quot;&apos;&quot;);
        }
        rd.forward(request, response);
    }
}</code></pre><p>可以看到，这个方法完成了最后把视图封装好和把结果返回给用户的操作</p>
<p>参考：<a href="https://segmentfault.com/a/1190000008471934" target="_blank" rel="noopener">DispatcherServlet来看spring mvc请求处理过程</a><br><a href="https://segmentfault.com/a/1190000015263978" target="_blank" rel="noopener">SpringMVC之源码分析–View（一）</a></p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
</search>
